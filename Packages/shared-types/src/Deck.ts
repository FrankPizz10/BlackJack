import { Card } from './Card';
import { Suit } from './Suit';
import { CardValue } from './CardValue';

export type Deck = {
  baseDeck: Card[];
  currentDeck: Card[];
  numDecks: number;
  shuffle: () => void;
  draw: () => Card | null;
};

export const createDeck = (numDecks: number = 1): Deck => {
  /**
   * Generates a base deck of cards.
   *
   * @param {number} numDecks The number of decks to generate.
   * @returns {CardPair[]} The base deck.
   */
  const generateBaseDeck = (numDecks: number): Card[] => {
    /**
     * The suits of a deck of cards.
     * @type {Suit[]}
     */
    const suits: Suit[] = ['H', 'D', 'C', 'S'];

    /**
     * The cards of a deck of cards.
     * @type {Card[]}
     */
    const cards: CardValue[] = [
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      '10',
      'J',
      'Q',
      'K',
      'A',
    ];

    /**
     * Use flatMap to create a single array from the array of arrays
     * generated by the map function.
     * The map function takes each card and creates an array of CardPair objects
     * by iterating over the suits array and creating a CardPair object for
     * each suit and card combination.
     */
    const singleDeck = suits.flatMap((suit) =>
      cards.map((card) => ({ suit, card }))
    );

    /**
     * If numDecks is greater than 1, use Array.fill to create an array of
     * length numDecks, and then use flatMap to combine the arrays into a
     * single array.
     * If numDecks is 1, then just return the singleDeck array.
     */
    return numDecks > 1
      ? Array(numDecks)
          .fill(null)
          .flatMap(() => singleDeck)
      : singleDeck;
  };

  /**
   * The base deck.
   * @type {CardPair[]}
   */
  const baseDeck = generateBaseDeck(numDecks);

  /**
   * The current deck.
   * @type {CardPair[]}
   */
  let currentDeck = [...baseDeck];

  /**
   * Shuffles the current deck.
   *
   * Uses the Fisher-Yates shuffle algorithm to shuffle the current deck.
   */
  const shuffle = (): void => {
    /**
     * Create a copy of the base deck to shuffle
     * @type {CardPair[]}
     */
    currentDeck = [...baseDeck];

    /**
     * Loop through the deck and swap each element with a random element
     * from the current index to the end of the deck
     */
    for (let i = currentDeck.length - 1; i > 0; i--) {
      /**
       * Get a random index between 0 and the current index
       * @type {number}
       */
      const randomIndex = Math.floor(Math.random() * (i + 1));

      /**
       * Swap the elements
       * @type {CardPair}
       */
      [currentDeck[i], currentDeck[randomIndex]] = [
        currentDeck[randomIndex],
        currentDeck[i],
      ];
    }
  };

  /**
   * Draws a card from the current deck.
   * If the deck is empty, returns null.
   *
   * @returns {CardPair | null} The drawn card, or null if the deck is empty.
   */
  const draw = (): Card | null => {
    /**
     * Check if there are cards left in the current deck
     * @type {boolean}
     */
    if (currentDeck.length > 0) {
      /**
       * Remove and return the first card from the deck
       * @type {CardPair}
       */
      return currentDeck.shift() || null;
    }
    /**
     * Return null if the deck is empty
     */
    return null;
  };

  return {
    baseDeck,
    currentDeck,
    numDecks,
    shuffle,
    draw
  };
};
